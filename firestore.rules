
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user document exists.
    function userDocExists(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    // Helper function to get user role.
    // Ensures user document and role field exist before accessing.
    function getUserRole(userId) {
      return userDocExists(userId) && 
             ('role' in get(/databases/$(database)/documents/users/$(userId)).data) ?
             get(/databases/$(database)/documents/users/$(userId)).data.role : null;
    }

    // Helper function to check if a user's role is one of an array of roles.
    function isUserRoleIn(userId, rolesArray) {
      let role = getUserRole(userId); // This line will be corrected by the rule below
      // Corrected:
      // return userDocExists(userId) && 
      //        (let role = get(/databases/$(database)/documents/users/$(userId)).data.role; role != null && role in rolesArray);
      // Simplified and corrected:
      return getUserRole(userId) != null && getUserRole(userId) in rolesArray;
    }
    
    // Helper function to check if an event document exists.
    function eventExists(eventId) {
      return exists(/databases/$(database)/documents/events/$(eventId));
    }

    // Helper function to check if a user is the organizer of a specific event.
    function isEventOrganizer(userId, eventId) {
      return eventExists(eventId) && 
             get(/databases/$(database)/documents/events/$(eventId)).data.organizerId == userId;
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      allow read: if request.auth != null &&
                      (
                        request.auth.uid == userId || // User can read their own profile
                        ( // Admin can read any profile
                          userDocExists(request.auth.uid) && // Corrected: check existence before getUserRole
                          isUserRole(request.auth.uid, 'admin')
                        ) ||
                        ( // Organizer/coadmin can read any user profile (for fetching student details for registrations)
                          userDocExists(request.auth.uid) && // Corrected
                          isUserRoleIn(request.auth.uid, ['organizer', 'coadmin'])
                        )
                      );
      allow create: if request.auth != null &&
                      request.auth.uid == userId &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.role == 'student' &&
                      request.resource.data.uid == request.auth.uid &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time;
      allow update: if request.auth != null &&
                        (
                          ( // User updating their own (limited fields)
                            request.auth.uid == userId &&
                            request.resource.data.uid == resource.data.uid &&
                            request.resource.data.email == resource.data.email &&
                            request.resource.data.role == resource.data.role && // Role not changeable by user here
                            request.resource.data.createdAt == resource.data.createdAt && // Cannot change createdAt
                            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'updatedAt'])
                          ) ||
                          ( // Admin updating any user
                            userDocExists(request.auth.uid) && // Corrected
                            isUserRole(request.auth.uid, 'admin') &&
                            request.resource.data.uid == resource.data.uid && // uid immutable
                            request.resource.data.email == resource.data.email && // email immutable by admin here for safety
                            request.resource.data.createdAt == resource.data.createdAt && // createdAt immutable
                            request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'name', 'updatedAt']) // Admin can change role, name
                          )
                        );
      allow list: if request.auth != null && 
                      userDocExists(request.auth.uid) && // Corrected
                      isUserRole(request.auth.uid, 'admin');
      allow delete: if request.auth != null &&
                      userDocExists(request.auth.uid) && // Corrected
                      isUserRole(request.auth.uid, 'admin');
    }

    // Rules for the 'events' collection
    match /events/{eventId} {
      allow list: if
        // Case 1: Public query for published events (query MUST filter for status == 'published')
        (
          request.query.filters.size() == 1 &&
          request.query.filters[0].fieldPath == 'status' &&
          request.query.filters[0].op == '==' &&
          request.query.filters[0].value == 'published'
        ) ||
        // Case 2: Authenticated users
        (
          request.auth != null &&
          userDocExists(request.auth.uid) && // User must exist to check role
          (
            // Admins can list all events (no further client query constraints needed for them here by THIS rule)
            isUserRole(request.auth.uid, 'admin') ||
            // Organizers/Coadmins can list events if their query filters by their own organizerId
            (
              isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) &&
              request.query.filters.size() > 0 && // Query must have at least one filter
              // Check if one of the filters is where('organizerId', '==', request.auth.uid)
              // Firestore rules don't have a direct 'find' for filters, so we check common scenarios or rely on get if query is complex
              // For simplicity and robustness, if the query by organizerId is complex, we might rely on GET rule protection
              // A common pattern is to allow if the query includes organizerId == request.auth.uid
              (
                (request.query.filters[0].fieldPath == 'organizerId' && request.query.filters[0].op == '==' && request.query.filters[0].value == request.auth.uid) ||
                (request.query.filters.size() > 1 && request.query.filters[1].fieldPath == 'organizerId' && request.query.filters[1].op == '==' && request.query.filters[1].value == request.auth.uid)
                // Add more specific checks if your queries have more filters in specific orders
              )
            )
          )
        );

      allow read: if (resource.data.status == 'published') || // Anyone can read a published event
                      (request.auth != null &&
                        userDocExists(request.auth.uid) && // User must exist for role checks
                        (
                          isUserRoleIn(request.auth.uid, ['admin', 'coadmin']) || // Admin or Coadmin can read any event
                          (isUserRoleIn(request.auth.uid, ['organizer']) && resource.data.organizerId == request.auth.uid) // Organizer can read their own events
                        )
                      );

      allow create: if request.auth != null &&
                      userDocExists(request.auth.uid) && // Corrected
                      isUserRoleIn(request.auth.uid, ['organizer', 'coadmin', 'admin']) &&
                      request.resource.data.organizerId == request.auth.uid &&
                      request.resource.data.status in ['draft', 'published', 'archived', 'completed'] &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                      request.resource.data.description is string && request.resource.data.description.size() > 0 &&
                      request.resource.data.date is timestamp &&
                      request.resource.data.venue is string && request.resource.data.venue.size() > 0 &&
                      request.resource.data.maxParticipants is number && request.resource.data.maxParticipants > 0;

      allow update: if request.auth != null &&
                      userDocExists(request.auth.uid) && // Corrected
                      (
                        (eventExists(eventId) && isEventOrganizer(request.auth.uid, eventId) && isUserRoleIn(request.auth.uid, ['organizer'])) || // Original Organizer
                        isUserRoleIn(request.auth.uid, ['coadmin', 'admin']) // Coadmins and Admins
                      ) &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.organizerId == resource.data.organizerId; // Prevent changing organizerId

      allow delete: if request.auth != null &&
                      userDocExists(request.auth.uid) && // Corrected
                      isUserRole(request.auth.uid, 'admin');
    }

    // Rules for the 'registrations' collection
    match /registrations/{registrationId} {
      allow list: if request.auth != null &&
                  (
                    // Student can list their own registrations for a specific event
                    (
                      userDocExists(request.auth.uid) && isUserRole(request.auth.uid, 'student') &&
                      request.query.filters.size() == 2 && // eventId and studentId
                      (
                        (request.query.filters[0].fieldPath == 'eventId' && request.query.filters[1].fieldPath == 'studentId' && request.query.filters[1].value == request.auth.uid) ||
                        (request.query.filters[0].fieldPath == 'studentId' && request.query.filters[0].value == request.auth.uid && request.query.filters[1].fieldPath == 'eventId')
                      )
                    ) ||
                    // Organizer/Coadmin can list registrations if query is filtered by an eventId they organize
                    (
                      userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) &&
                      request.query.filters.size() > 0 && // Query must have at least one filter
                      eventExists(request.query.filters[0].fieldPath == 'eventId' ? request.query.filters[0].value : (request.query.filters.size() > 1 && request.query.filters[1].fieldPath == 'eventId' ? request.query.filters[1].value : '____dummy_non_matching_event_id____')) && // Get eventId from query
                      isEventOrganizer(request.auth.uid, request.query.filters[0].fieldPath == 'eventId' ? request.query.filters[0].value : (request.query.filters.size() > 1 && request.query.filters[1].fieldPath == 'eventId' ? request.query.filters[1].value : '____dummy_non_matching_event_id____'))
                    ) ||
                    // Admin can list all registrations
                    (
                      userDocExists(request.auth.uid) && isUserRole(request.auth.uid, 'admin')
                    )
                  );


      allow read: if request.auth != null && (
                      (resource.data.studentId == request.auth.uid) || // Student reads their own
                      ( // Organizer/Coadmin/Admin read based on event or admin role
                        userDocExists(request.auth.uid) &&
                        isUserRoleIn(request.auth.uid, ['organizer', 'coadmin', 'admin']) &&
                        eventExists(resource.data.eventId) &&
                        (isEventOrganizer(request.auth.uid, resource.data.eventId) || isUserRole(request.auth.uid, 'admin'))
                      )
                    );

      allow create: if request.auth != null &&
                      request.resource.data.studentId == request.auth.uid &&
                      userDocExists(request.auth.uid) && // Corrected
                      isUserRole(request.auth.uid, 'student') &&
                      eventExists(request.resource.data.eventId) &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.registeredAt == request.time &&
                      request.resource.data.eventId is string &&
                      request.resource.data.qrCodeData is string;

      allow update: if request.auth != null &&
                      userDocExists(request.auth.uid) && // Corrected
                      (
                        ( // Organizer/Coadmin for their event
                          isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) &&
                          eventExists(resource.data.eventId) &&
                          isEventOrganizer(request.auth.uid, resource.data.eventId) &&
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'checkedInAt', 'updatedAt']) && // Allow specific field updates
                          (!('status' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.status in ['pending', 'approved', 'rejected', 'attended'])
                        ) ||
                        ( // Admin can update specific fields
                          isUserRole(request.auth.uid, 'admin') &&
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'checkedInAt', 'qrCodeData', 'updatedAt']) && // Allow specific field updates
                          (!('status' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.status in ['pending', 'approved', 'rejected', 'attended'])
                        )
                      ) &&
                      request.resource.data.updatedAt == request.time && 
                      request.resource.data.studentId == resource.data.studentId && 
                      request.resource.data.eventId == resource.data.eventId;

      allow delete: if false;
    }
  }
}

    