
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user document exists
    function userDocExists(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }

    // Helper function to get user role (safer)
    function getUserRole(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      // Check if role field exists before trying to access it
      return userDocExists(userId) && ('role' in userDoc.data) ? userDoc.data.role : null;
    }

    // Helper function to check if user has one of the specified roles
    function isUserRoleIn(userId, rolesArray) {
      let role = getUserRole(userId); // This will be null if userDoc or role field doesn't exist
      return role != null && role in rolesArray;
    }
    
    // Helper function to check if an event document exists
    function eventExists(eventId) {
      return exists(/databases/$(database)/documents/events/$(eventId));
    }
    
    // Helper function to get event data (safer)
    function getEventData(eventId) {
        return get(/databases/$(database)/documents/events/$(eventId)).data;
    }

    // Helper function to check if a user is the organizer of a specific event
    function isEventOrganizer(userId, eventId) {
      return eventExists(eventId) && getEventData(eventId).organizerId == userId;
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      // User can read their own profile, OR Admin can read any profile, OR Organizer/Coadmin can read any profile (for registration management)
      allow read: if request.auth != null &&
                      (
                        request.auth.uid == userId ||
                        (userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin', 'organizer', 'coadmin']))
                      );

      // Anyone can create their own user document (on signup)
      allow create: if request.auth != null && request.auth.uid == userId &&
                      request.resource.data.uid == userId && 
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.role == 'student' && // Default role on creation
                      // Ensure server timestamps are being set by server, not client
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time &&
                      // Client must send these fields
                      request.resource.data.keys().hasAll(['uid', 'email', 'role', 'createdAt', 'updatedAt']) &&
                      // Client can optionally send 'name', but no other fields
                      request.resource.data.keys().hasOnly(['uid', 'email', 'role', 'name', 'createdAt', 'updatedAt']);

      allow update: if request.auth != null && (
                      // User updating their own profile (limited fields)
                      (request.auth.uid == userId &&
                        // Immutable fields that user cannot change themselves
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.email == resource.data.email &&
                        request.resource.data.role == resource.data.role &&
                        request.resource.data.createdAt == resource.data.createdAt &&
                        // Fields user is allowed to change + server timestamp
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['name', 'updatedAt']) &&
                        request.resource.data.updatedAt == request.time
                      ) ||
                      // Admin updating any user profile
                      (userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin']) &&
                        // Immutable fields admin should not change here easily
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.email == resource.data.email &&
                        request.resource.data.createdAt == resource.data.createdAt &&
                        // Fields admin is allowed to change + server timestamp
                        request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'name', 'updatedAt']) && // Admins can change role
                        request.resource.data.updatedAt == request.time
                      )
                    );
      
      // Admins can list users
      allow list: if request.auth != null && userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin']);
      
      // Admins can delete users
      allow delete: if request.auth != null && userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin']);
    }

    // Rules for the 'events' collection
    match /events/{eventId} {
      // Read rules:
      // 1. Anyone can get a 'published' event.
      // 2. Authenticated organizers/coadmins/admins can get any event they are related to or any event if admin.
      allow get: if (resource.data.status == 'published') ||
                     (request.auth != null && userDocExists(request.auth.uid) &&
                       (
                         isUserRoleIn(request.auth.uid, ['admin', 'coadmin']) ||
                         (isUserRoleIn(request.auth.uid, ['organizer']) && resource.data.organizerId == request.auth.uid)
                       )
                     );

      // List rules:
      // 1. Anyone can list events IF the query filters for 'status' == 'published'.
      // 2. Authenticated Admins can list all events.
      // 3. Authenticated Organizers/Coadmins can list events IF the query filters for their 'organizerId'.
      allow list: if (
                      (request.query.filters.size() == 1 && request.query.filters[0].fieldPath == 'status' && request.query.filters[0].op == '==' && request.query.filters[0].value == 'published') // Public published list
                    ) ||
                    (request.auth != null && userDocExists(request.auth.uid) &&
                      (
                        isUserRoleIn(request.auth.uid, ['admin']) || // Admin lists all
                        ( // Organizer/Coadmin lists their own
                          isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) &&
                          request.query.filters.size() >= 1 && // Must have at least one filter
                          request.query.filters.find(f => f.fieldPath == 'organizerId' && f.op == '==' && f.value == request.auth.uid) != null
                        )
                      )
                    );
      
      // Create rules:
      allow create: if request.auth != null && userDocExists(request.auth.uid) &&
                      isUserRoleIn(request.auth.uid, ['organizer', 'coadmin', 'admin']) &&
                      request.resource.data.organizerId == request.auth.uid && // Creator must be organizer
                      request.resource.data.status == 'draft' && // Default to draft
                      request.resource.data.name is string && request.resource.data.name.size() > 0 &&
                      request.resource.data.description is string &&
                      request.resource.data.date is timestamp &&
                      request.resource.data.venue is string && request.resource.data.venue.size() > 0 &&
                      request.resource.data.maxParticipants is number && request.resource.data.maxParticipants > 0 &&
                      (request.resource.data.imageUrl is string || request.resource.data.imageUrl == null) &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.keys().hasAll(['name', 'description', 'date', 'venue', 'maxParticipants', 'organizerId', 'status', 'createdAt', 'updatedAt']) &&
                      request.resource.data.keys().hasOnly(['name', 'description', 'date', 'venue', 'maxParticipants', 'imageUrl', 'organizerId', 'status', 'createdAt', 'updatedAt']);

      // Update rules:
      allow update: if request.auth != null && userDocExists(request.auth.uid) &&
                      (
                        (isEventOrganizer(request.auth.uid, eventId) && isUserRoleIn(request.auth.uid, ['organizer'])) || // Original Organizer
                        isUserRoleIn(request.auth.uid, ['coadmin', 'admin']) // Coadmins and Admins
                      ) &&
                      // Prevent changing immutable fields
                      request.resource.data.organizerId == resource.data.organizerId &&
                      request.resource.data.createdAt == resource.data.createdAt &&
                      // Allowed fields to update
                      request.resource.data.diff(resource.data).affectedKeys().hasAny(['name', 'description', 'date', 'venue', 'maxParticipants', 'imageUrl', 'status', 'updatedAt']) &&
                      request.resource.data.updatedAt == request.time;

      // Delete rules:
      allow delete: if request.auth != null && userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin']);
    }

    // Rules for the 'registrations' collection
    match /registrations/{registrationId} {
      // Any authenticated user can perform list queries.
      // Security for individual document data relies on the 'read' (get) rule below.
      // This supports students checking their own registration for an event,
      // and organizers/admins listing registrations for events they manage.
      allow list: if request.auth != null &&
                  (
                    // Case 1: Student querying their own registration for a specific event
                    (
                      userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['student']) &&
                      request.query.filters.size() == 2 && // Expects two filters: studentId and eventId
                      (
                        (request.query.filters[0].fieldPath == 'studentId' && request.query.filters[0].op == '==' && request.query.filters[0].value == request.auth.uid &&
                         request.query.filters[1].fieldPath == 'eventId' && request.query.filters[1].op == '==') ||
                        (request.query.filters[1].fieldPath == 'studentId' && request.query.filters[1].op == '==' && request.query.filters[1].value == request.auth.uid &&
                         request.query.filters[0].fieldPath == 'eventId' && request.query.filters[0].op == '==')
                      )
                    ) ||
                    // Case 2: Organizer/Coadmin listing registrations for an event they manage
                    (
                      userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) &&
                      request.query.filters.size() >= 1 && // Must have at least one filter
                      request.query.filters.find(f => f.fieldPath == 'eventId' && f.op == '==' && eventExists(f.value) && isEventOrganizer(request.auth.uid, f.value) ) != null
                    ) ||
                    // Case 3: Admin listing registrations (can be less restrictive here if needed, or require eventId filter)
                    (
                      userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin'])
                      // Optionally add: && request.query.filters.get('eventId') is string
                    )
                  );


      allow read: if request.auth != null && (
                      (userDocExists(request.auth.uid) && resource.data.studentId == request.auth.uid) || // Student reads their own
                      (userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['admin'])) || // Admin reads any
                      (userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) && eventExists(resource.data.eventId) && isEventOrganizer(request.auth.uid, resource.data.eventId)) // Organizer/Coadmin for their event
                    );

      allow create: if request.auth != null &&
                      userDocExists(request.auth.uid) && isUserRoleIn(request.auth.uid, ['student']) && // User must exist and be a student
                      request.resource.data.studentId == request.auth.uid && // Can only register self
                      request.resource.data.status == 'pending' && // Initial status must be pending
                      eventExists(request.resource.data.eventId) && // Event must exist
                      request.resource.data.eventId is string && request.resource.data.eventId.size() > 0 &&
                      request.resource.data.qrCodeData is string && request.resource.data.qrCodeData.size() > 0 &&
                      request.resource.data.registeredAt == request.time && // Server sets timestamp
                      !('checkedInAt' in request.resource.data) && // checkedInAt not set on create
                      request.resource.data.keys().hasOnly(['eventId', 'studentId', 'status', 'qrCodeData', 'registeredAt']);


      allow update: if request.auth != null && userDocExists(request.auth.uid) &&
                      eventExists(resource.data.eventId) && // The registration must be for an existing event
                      (
                        // Organizer or Coadmin for their event can update status/checkedInAt
                        (
                          isUserRoleIn(request.auth.uid, ['organizer', 'coadmin']) &&
                          isEventOrganizer(request.auth.uid, resource.data.eventId) &&
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'checkedInAt', 'updatedAt']) &&
                          (!('status' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.status in ['pending', 'approved', 'rejected', 'attended']) &&
                          (!('checkedInAt' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.checkedInAt is timestamp || request.resource.data.checkedInAt == null)
                        ) ||
                        // Admin can update status/checkedInAt/qrCodeData
                        (
                          isUserRoleIn(request.auth.uid, ['admin']) &&
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'checkedInAt', 'qrCodeData', 'updatedAt']) &&
                          (!('status' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.status in ['pending', 'approved', 'rejected', 'attended']) &&
                          (!('checkedInAt' in request.resource.data.diff(resource.data).affectedKeys()) || request.resource.data.checkedInAt is timestamp || request.resource.data.checkedInAt == null)
                        )
                      ) &&
                      request.resource.data.updatedAt == request.time && // Server sets timestamp
                      // Immutable fields
                      request.resource.data.studentId == resource.data.studentId &&
                      request.resource.data.eventId == resource.data.eventId &&
                      request.resource.data.registeredAt == resource.data.registeredAt;

      allow delete: if false;
    }
  }
}

    